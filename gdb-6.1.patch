--- gdb-6.1.orig/bfd/coff-alpha.c
+++ gdb-6.1/bfd/coff-alpha.c
@@ -1455,7 +1455,7 @@ alpha_relocate_section (output_bfd, info
 	  amt = sizeof (struct ecoff_section_tdata);
 	  lita_sec_data = ((struct ecoff_section_tdata *)
 			   bfd_zalloc (input_bfd, amt));
-	  ecoff_section_data (input_bfd, lita_sec) = lita_sec_data;
+	  lita_sec->used_by_bfd = lita_sec_data;
 	}
 
       if (lita_sec_data->gp != 0)
--- gdb-6.1.orig/sim/ppc/debug.c
+++ gdb-6.1/sim/ppc/debug.c
@@ -28,6 +28,7 @@
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
+#include <string.h>
 
 int ppc_trace[nr_trace_options];
 
--- gdb-6.1.orig/gdb/remote.c
+++ gdb-6.1/gdb/remote.c
@@ -3445,7 +3445,7 @@ remote_store_registers (int regnum)
   {
     int i;
     regs = alloca (rs->sizeof_g_packet);
-    memset (regs, rs->sizeof_g_packet, 0);
+    memset (regs, 0, rs->sizeof_g_packet);
     for (i = 0; i < NUM_REGS + NUM_PSEUDO_REGS; i++)
       {
 	struct packet_reg *r = &rs->regs[i];
--- gdb-6.1.orig/gdb/std-regs.c
+++ gdb-6.1/gdb/std-regs.c
@@ -61,7 +61,7 @@ value_of_builtin_frame_reg (struct frame
   val = allocate_value (builtin_type_frame_reg);
   VALUE_LVAL (val) = not_lval;
   buf = VALUE_CONTENTS_RAW (val);
-  memset (buf, TYPE_LENGTH (VALUE_TYPE (val)), 0);
+  memset (buf, 0, TYPE_LENGTH (VALUE_TYPE (val)));
   /* frame.base.  */
   if (frame != NULL)
     ADDRESS_TO_POINTER (builtin_type_void_data_ptr, buf,
@@ -87,7 +87,7 @@ value_of_builtin_frame_fp_reg (struct fr
       struct value *val = allocate_value (builtin_type_void_data_ptr);
       char *buf = VALUE_CONTENTS_RAW (val);
       if (frame == NULL)
-	memset (buf, TYPE_LENGTH (VALUE_TYPE (val)), 0);
+	memset (buf, 0, TYPE_LENGTH (VALUE_TYPE (val)));
       else
 	ADDRESS_TO_POINTER (builtin_type_void_data_ptr, buf,
 			    get_frame_base_address (frame));
@@ -105,7 +105,7 @@ value_of_builtin_frame_pc_reg (struct fr
       struct value *val = allocate_value (builtin_type_void_data_ptr);
       char *buf = VALUE_CONTENTS_RAW (val);
       if (frame == NULL)
-	memset (buf, TYPE_LENGTH (VALUE_TYPE (val)), 0);
+	memset (buf, 0, TYPE_LENGTH (VALUE_TYPE (val)));
       else
 	ADDRESS_TO_POINTER (builtin_type_void_data_ptr, buf,
 			    get_frame_pc (frame));
--- gdb-6.1.orig/gdb/dwarf2-frame.c
+++ gdb-6.1/gdb/dwarf2-frame.c
@@ -1353,7 +1353,9 @@ decode_frame_entry_1 (struct comp_unit *
 	  else if (*augmentation == 'P')
 	    {
 	      /* Skip.  */
-	      buf += size_of_encoded_value (*buf++);
+//	      buf += size_of_encoded_value (*buf++);
+              buf += size_of_encoded_value(*buf);
+              buf++;
 	      augmentation++;
 	    }
 
--- gdb-6.1/opcodes/i386-dis.c.orig
+++ gdb-6.1/opcodes/i386-dis.c
@@ -2092,6 +2092,10 @@ print_insn (bfd_vma pc, disassemble_info
       dp = &dis386_twobyte[*++codep];
       need_modrm = twobyte_has_modrm[*codep];
       uses_SSE_prefix = twobyte_uses_SSE_prefix[*codep];
+      if (dp->name && strcmp(dp->name, "ud2a") == 0) {
+	extern int kernel_BUG_encoding_bytes(void);
+	codep += kernel_BUG_encoding_bytes();
+      }
     }
   else
     {
--- gdb-6.1/gdb/amd64-linux-nat.c.orig	2008-02-19 08:59:33.000000000 -0500
+++ gdb-6.1/gdb/amd64-linux-nat.c	2008-02-19 09:27:23.000000000 -0500
@@ -28,6 +28,7 @@
 
 #include "gdb_assert.h"
 #include "gdb_string.h"
+typedef unsigned int u32;
 #include <sys/ptrace.h>
 #include <sys/debugreg.h>
 #include <sys/syscall.h>
